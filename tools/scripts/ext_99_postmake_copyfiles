#!/bin/bash
set -e

DISPLAYNAME="复制或合并文件"
source "$(dirname "$(readlink -f "$0")")/common/common"

mergedJSONFiles=()
mergedJSONFilesIndex=0

function makeSureHaveDirectory()
{
    dirName="$(dirname "${1}")"
    if [ ! -d "${dirName}" ];then mkdir -p "${dirName}"; fi
}

function pack()
{
    local srcPath="${1}"
    local destPath="${2}"

    log "将 ${srcPath} 覆盖到 ${destPath} 上"

    #获取文件列表
    files=$(find "${srcPath}" -type f)

    #遍历文件来检查，这样允许脚本进行合并JSON这类的操作
    for file in $files; do
        #包内相对名称
        fileResolved="${file//$srcPath'/'/}"
        finalFile="${destPath}/./${fileResolved}"
        makeSureHaveDirectory "${finalFile}"

        #合并JSON
        #只合并Minecraft命名空间下的JSON
        if [[ "$fileResolved" == *minecraft/*.json ]];then

            #log LWARN "FILE ${fileResolved}"

            sourceFileContent="$(cat "${file}" 2>/dev/null || true)"
            finalFileContent="$(cat "${finalFile}" 2>/dev/null || true)"

            #确保finalFile不为空
            if [ ! -f "${finalFile}" ] || [ -z "${finalFileContent}" ];then
                    #log LWARN "没有finalFile内容，正在创建"
                    echo "{}" > "${finalFile}"
            fi

            #确保内容合法
            if ! jq < "${finalFile}" >/dev/null; then
                #log LWARN "非法JSON内容，正在重置finalFile"
                echo "{}" > "${finalFile}"
            fi

            if [[ ! "${mergedJSONFiles[*]}" =~ "${finalFile}" ]];then
                ((mergedJSONFilesIndex += 1))
                mergedJSONFiles[${mergedJSONFilesIndex}]="${finalFile}"
                echo "{}" > "${finalFile}"
            fi

            #比较文件内容，如果一样则跳过，不要合并
            if [ ! "${finalFileContent}" == "${sourceFileContent}" ];then
                log LINFO "MERG ${file} --- ${finalFile}"

                #合并结果
                #根据类型合并
                if [[ "${file}" == *minecraft/models/* ]];then
                    #先合并overrides
                    result="$(jq 'reduce inputs as $i (.; .overrides += $i.overrides)' "${file}" "${finalFile}")"
                    
                    #然后根据CustomModelData排序
                    #不排序会有问题
                    result=$(echo "${result}" | jq '.overrides|=sort_by(.predicate.custom_model_data)')
                else
                    result="$(jq -s '.[1] * .[0]' "${file}" "${finalFile}")"
                fi

                #输出内容
                echo "${result}" > "${finalFile}"
            fi;
        else
            if [ -f "${finalFile}" ] && [ ! "$(md5sum "${file}"  | cut -d ' ' -f1)" == "$(md5sum "${finalFile}" | cut -d ' ' -f1)" ];then
                log LWARN "文件${file}可能与${finalFile}有冲突"
            fi

            cp "${file}" "${finalFile}"
        fi

            done
    
    log "${srcPath} 覆盖完成"

}

#复制文件
for srcName in ./src_*; do
    productName="${srcName/src/pack}"

    #log "将${srcName}的本体复制到${productName}..."
    #cp "$srcName/main"/* "$productName/" -r

    #复制文件
    #如果有扩展包：
    if [ -n "$(ls "$srcName" | grep "ext_")" ];then
        #遍历扩展包
        for extPack in "$srcName"/ext_*; do
            pack "${extPack}" "${productName}"
        done;
    fi

    #最后把主包覆盖上去
    pack "${srcName}/main" "${productName}"
done;